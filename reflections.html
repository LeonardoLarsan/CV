<!DOCTYPE html>
<html lang="es-ES">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.26">
    <title>Reflexiones | Leonardo Larrosa</title><meta name="description" content="Full Stack Lead Developer">
    <link rel="preload" href="/CV/assets/js/runtime~app.fd959f96.js" as="script"><link rel="preload" href="/CV/assets/css/styles.73e9edf3.css" as="style"><link rel="preload" href="/CV/assets/js/812.4ffac0d4.js" as="script"><link rel="preload" href="/CV/assets/js/app.81cd1d29.js" as="script">
    <link rel="stylesheet" href="/CV/assets/css/styles.73e9edf3.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/CV/" class=""><img class="logo" src="/CV/images/logo.png" alt="Leonardo Larrosa"><span class="site-name can-hide">Leonardo Larrosa</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/CV/profile.html" class="nav-link" aria-label="Perfil"><!--[--><!--]--> Perfil <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/skills.html" class="nav-link" aria-label="Conocimientos y Habilidades"><!--[--><!--]--> Conocimientos y Habilidades <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/data.html" class="nav-link" aria-label="Datos"><!--[--><!--]--> Datos <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/education.html" class="nav-link" aria-label="Educación"><!--[--><!--]--> Educación <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/experiencie.html" class="nav-link" aria-label="Experiencia Laboral"><!--[--><!--]--> Experiencia Laboral <!--[--><!--]--></a></div><div class="navbar-links-item"><a aria-current="page" href="/CV/reflections.html" class="router-link-active router-link-exact-active nav-link router-link-active" aria-label="Reflexiones"><!--[--><!--]--> Reflexiones <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/about.html" class="nav-link" aria-label="Sobre mi"><!--[--><!--]--> Sobre mi <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/CV/profile.html" class="nav-link" aria-label="Perfil"><!--[--><!--]--> Perfil <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/skills.html" class="nav-link" aria-label="Conocimientos y Habilidades"><!--[--><!--]--> Conocimientos y Habilidades <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/data.html" class="nav-link" aria-label="Datos"><!--[--><!--]--> Datos <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/education.html" class="nav-link" aria-label="Educación"><!--[--><!--]--> Educación <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/experiencie.html" class="nav-link" aria-label="Experiencia Laboral"><!--[--><!--]--> Experiencia Laboral <!--[--><!--]--></a></div><div class="navbar-links-item"><a aria-current="page" href="/CV/reflections.html" class="router-link-active router-link-exact-active nav-link router-link-active" aria-label="Reflexiones"><!--[--><!--]--> Reflexiones <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/CV/about.html" class="nav-link" aria-label="Sobre mi"><!--[--><!--]--> Sobre mi <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">Reflexiones</p><ul class=""><li><!--[--><a aria-current="page" href="/CV/reflections.html#experiencias-que-han-marcado-mi-evolucion-como-desarrollador" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Experiencias que han marcado mi evolución como desarrollador"><!--[--><!--]--> Experiencias que han marcado mi evolución como desarrollador <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-apostar-a-un-codigo-de-alta-calidad-y-no-a-la-productividad-inmediata" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué apostar a un código de alta calidad y no a la productividad inmediata?"><!--[--><!--]--> ¿Por qué apostar a un código de alta calidad y no a la productividad inmediata? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-a-veces-lo-mejor-es-priorizar-la-calidad-por-sobre-las-metodologias" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué a veces lo mejor es priorizar la calidad por sobre las metodologías?"><!--[--><!--]--> ¿Por qué a veces lo mejor es priorizar la calidad por sobre las metodologías? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-defiendo-clean-code-y-no-otras-practicas-de-desarrollo" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué defiendo Clean Code y no otras prácticas de desarrollo?"><!--[--><!--]--> ¿Por qué defiendo Clean Code y no otras prácticas de desarrollo? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-prefiero-implementar-clean-code-y-no-una-buena-documentacion" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué prefiero implementar Clean Code y no una buena documentación?"><!--[--><!--]--> ¿Por qué prefiero implementar Clean Code y no una buena documentación? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-un-lenguaje-tipado-y-no-uno-dinamico" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué un lenguaje tipado y no uno dinámico?"><!--[--><!--]--> ¿Por qué un lenguaje tipado y no uno dinámico? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#valores-por-defecto-segun-su-tipo-y-no-resultados-dinamicos" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Valores por defecto según su tipo y no resultados dinámicos."><!--[--><!--]--> Valores por defecto según su tipo y no resultados dinámicos. <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-programacion-declarativa-y-no-imperativa" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué programación declarativa y no imperativa?"><!--[--><!--]--> ¿Por qué programación declarativa y no imperativa? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-programacion-funcional-y-no-orientada-a-objetos" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué programación funcional y no orientada a objetos?"><!--[--><!--]--> ¿Por qué programación funcional y no orientada a objetos? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-clean-arquitecture-y-no-cualquier-improvisacion-o-solucion-rapida" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué Clean Arquitecture y no cualquier improvisación o solución rápida?"><!--[--><!--]--> ¿Por qué Clean Arquitecture y no cualquier improvisación o solución rápida? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-github-flow-y-no-gitlab-flow" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué GitHub Flow y no GitLab Flow?"><!--[--><!--]--> ¿Por qué GitHub Flow y no GitLab Flow? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-kanban-y-no-scrum" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué Kanban y no SCRUM?"><!--[--><!--]--> ¿Por qué Kanban y no SCRUM? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#¿por-que-acordar-tareas-en-base-a-descripciones-y-no-en-base-a-palabras" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="¿Por qué acordar tareas en base a descripciones y no en base a palabras?"><!--[--><!--]--> ¿Por qué acordar tareas en base a descripciones y no en base a palabras? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/CV/reflections.html#considerar-todos-los-puntos-de-vista-y-no-asumir-veracidades-propias" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Considerar todos los puntos de vista y no asumir veracidades propias"><!--[--><!--]--> Considerar todos los puntos de vista y no asumir veracidades propias <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="reflexiones" tabindex="-1"><a class="header-anchor" href="#reflexiones" aria-hidden="true">#</a> Reflexiones</h1><h2 id="experiencias-que-han-marcado-mi-evolucion-como-desarrollador" tabindex="-1"><a class="header-anchor" href="#experiencias-que-han-marcado-mi-evolucion-como-desarrollador" aria-hidden="true">#</a> Experiencias que han marcado mi evolución como desarrollador</h2><h3 id="¿por-que-apostar-a-un-codigo-de-alta-calidad-y-no-a-la-productividad-inmediata" tabindex="-1"><a class="header-anchor" href="#¿por-que-apostar-a-un-codigo-de-alta-calidad-y-no-a-la-productividad-inmediata" aria-hidden="true">#</a> ¿Por qué apostar a un código de alta calidad y no a la productividad inmediata?</h3><p>A menudo vemos que los desarrolladores son presionados para que aumenten su productividad con fechas de entrega límite que son muy exigentes, lo que provoca que estos caigan en malas prácticas de desarrollo que arruinan la calidad del código. Frente a esta situación, las soluciones rápidas, y en el momento, son fáciles de implementar cuando los proyectos recién comienzan, pero cuando estos aumentan de tamaño, y se va agregando mayor número de características, estas van aumentando en complejidad, a tal punto que se vuelve demasiado difícil para un desarrollador poder mantener esos proyectos cuando el código escrito es ilegible, desordenado e impredecible.</p><p>Este problema es conocido como la tan temida “deuda técnica” y, a pesar de que es un tema muy conocido en el ámbito de desarrollo de software, muchos líderes técnicos y CTOs subestiman enormemente este problema. Ellos piensan que las soluciones o desarrollos rápidos, centrados únicamente en la funcionalidad y no en la calidad, son sinónimo de alta productividad, ya que ellos pueden hacer entregas rápidas de funcionalidades nuevas a los clientes. Sin embargo, cuando el código de baja calidad aumenta de tamaño se vuelve exponencialmente más difícil de mantener, y esto se traduce en una perdida de productividad en el sector de desarrollo, y esto intentan resolverlo presionando aun más a los desarrolladores para que alcancen los niveles de productividad que tenían al principio de los proyectos, cuando aun eran mantenibles, de manera que los desarrolladores terminan estresados, desmoralizados y desgastados mentalmente. Este ritmo de trabajo solo puede ser sostenido por los desarrolladores por un periodo limitado, luego de ese tiempo bajan considerablemente su productividad al encontrarse padeciendo el síndrome de burnout.</p><p>Intentar contratar desarrolladores nuevos para resolver esta situación también es un error. Los nuevos miembros del equipo, que ingresan con muchas ganas de aportar, tendrán que luchar con el desorden y el caos de los proyectos. Y, ante la necesidad de mostrarse resolutivos, y al no haber patrones, arquitectura, ni nada definido, ellos trataran de resolver sus problemas de la manera que mejor les parezca y, por ende, introducirán soluciones rápidas que aumentaran aun más la deuda técnica existente. El tiempo seguirá avanzando, y con él la complejidad de los proyectos y su deuda técnica. La productividad bajará tanto que, aunque incorporen nuevos miembros al equipo, es poco lo que se podrá seguir avanzando, ya que, ante el más mínimo cambio u agregado en el código, se deberá invertir una gran cantidad de esfuerzo para solucionar los nuevos errores introducidos. En este tipo de casos, como lamentablemente nunca se “pagó” la deuda técnica, los proyectos entran en bancarrota técnica, y es entonces cuando los sectores de IT deciden migrar los proyectos a nuevas tecnologías, culpando a las anteriores tecnologías como causante de los fracasos.</p><p>Todo lo anterior sucede muy a menudo porque los líderes suelen subestimar el valor del trabajo técnico y su calidad, también porque ignoran o no comprenden como las buenas prácticas mejoran la calidad del código y, ante esta carencia, naturalizan la dificultad exponencial que va surgiendo en el día a día, durante el proceso de desarrollo de software.</p><p>Lamentablemente muchos líderes justifican sus malas decisiones argumentando que para poder escribir código de alto nivel se necesitaría invertir una mayor cantidad de tiempo y esfuerzo para realizar nuevas funcionalidades, y que esto provoca pérdidas de productividad en el desarrollo. Sin embargo, a pesar de que tienen razón en el corto plazo, ya que las nuevas funcionalidades se terminan entregando más tarde, ellos ignoran completamente que a mediano y largo plazo, un código inmanejable se convierte exponencialmente más difícil de mantener. Por lo tanto, un código de alta calidad resulta ser más fácil de mantener y es más productivo en la mayoría de los proyectos de hoy en día, ya que estos aumentan de tamaño y complejidad con el tiempo.</p><h3 id="¿por-que-a-veces-lo-mejor-es-priorizar-la-calidad-por-sobre-las-metodologias" tabindex="-1"><a class="header-anchor" href="#¿por-que-a-veces-lo-mejor-es-priorizar-la-calidad-por-sobre-las-metodologias" aria-hidden="true">#</a> ¿Por qué a veces lo mejor es priorizar la calidad por sobre las metodologías?</h3><p>Habitualmente, cuando los proyectos inician y son mantenibles, no se le da importancia a las metodologías ágiles ni a los procesos formales de desarrollo. Estos suelen cobrar importancia tardíamente, cuando el código ya se ha tornado inmantenible por su aumento de tamaño y complejidad, que genera baja productividad.</p><p>Opino que es un error, en este tipo de situaciones, que se priorice las metodologías por sobre la calidad del código. Al comienzo del proyecto, la metodología, la organización y los procesos de desarrollo ayudan pero, con el tiempo la deuda técnica avanza, y aunque se hagan enormes esfuerzos para prevenir errores con el sector de QA, y que los problemas de estimaciones se intenten solucionar afinando más la organización, planificación, y los procesos formales de desarrollo, con cada sprint habrá más y más retrasos, y más bugs. Todos los esfuerzos que se hagan por fuera del código para compensar las deficiencias de éste no sirven, porque es como la basura que se esconde debajo de la alfombra, la basura que es el código seguirá acumulándose y la alfombra en un punto ya no alcanzará para tapar tanta basura. Lo mejor es arreglar todo ese desastre y no intentar taparlo.</p><p>Los problemas del código se solucionan trabajando en el mismo código, mejorando la calidad del mismo por etapas, de a poco con sucesivos refactors, aplicando buenas prácticas hasta llegar a obtener un código limpio y mantenible.</p><h3 id="¿por-que-defiendo-clean-code-y-no-otras-practicas-de-desarrollo" tabindex="-1"><a class="header-anchor" href="#¿por-que-defiendo-clean-code-y-no-otras-practicas-de-desarrollo" aria-hidden="true">#</a> ¿Por qué defiendo Clean Code y no otras prácticas de desarrollo?</h3><p>Clean Code es una filosofía de desarrollo de software, con un listado de reglas y un conjunto de buenas prácticas de desarrollo, muchas de ellas tomadas de otros lados, que facilitan la escritura y lectura de un código, haciéndolo más fácil de entender y, que por lo tanto, aseguran su mantenibilidad. A diferencia de otras prácticas más difíciles de implementar, como TDD que requiere tener mucho de conocimiento de testing, Clean Code puede ser aplicada por todos los desarrolladores, con tan solo aplicar algunas reglas simples ya se puede asegurar la viabilidad de un proyecto a largo plazo. Un código limpio y elegante es fácil y barato de evolucionar, escalar y mantener.</p><h3 id="¿por-que-prefiero-implementar-clean-code-y-no-una-buena-documentacion" tabindex="-1"><a class="header-anchor" href="#¿por-que-prefiero-implementar-clean-code-y-no-una-buena-documentacion" aria-hidden="true">#</a> ¿Por qué prefiero implementar Clean Code y no una buena documentación?</h3><p>Una documentación muchas veces miente o no dice toda la verdad. Es texto que, frecuentemente, queda desfasado de la realidad, o no refleja la funcionalidad del código que ha sufrido reiterados cambios. También puede suceder que los desarrolladores no mantengan actualizada la documentación. A fin de cuentas, no hay mejor fuente de la verdad que el código mismo, porque el código se ejecuta y funciona. Por esta razón es importante que el código sea legible, predecible y mantenible. Cualquier regla de negocio compleja que se ha olvidado, fácilmente se la puede recordar leyendo un código bien escrito.</p><h3 id="¿por-que-un-lenguaje-tipado-y-no-uno-dinamico" tabindex="-1"><a class="header-anchor" href="#¿por-que-un-lenguaje-tipado-y-no-uno-dinamico" aria-hidden="true">#</a> ¿Por qué un lenguaje tipado y no uno dinámico?</h3><p>Es típico ver a un desarrollador JavaScript debugueando, teniendo que ejecutar su aplicación e insertando “console.log” en el código para ver en la consola si se están enviando correctamente los datos, o si estos llegan con el formato correcto, etc. Los lenguajes dinámicos cuando son usados correctamente resultan ser muy prácticos, pero cuando se abusa de las virtudes y flexibilidad que poseen, pueden generar código poco predecible, ilegible y muy propenso a errores.</p><p>Lamentablemente, los programadores que solo han usado lenguajes dinámicos, no tienen bien claro como y cuando es correcto usar las virtudes de estos lenguajes, y cuando esto sucede, crean código dinámico que es muy difícil de mantener. Los lenguajes tipados vienen a solucionar este problema, ya que son lenguajes bien documentados y predecibles, y son muy estrictos en como manejan los datos.</p><p>Los defensores de los lenguajes dinámicos dirán que los lenguajes tipados agregan una capa de abstracción innecesaria para el manejo de los datos, y que merma la productividad. Esto es medianamente cierto porque al inicio hay que invertir tiempo en definir en como va a ser los datos, pero a mediano y largo plazo, estos lenguajes ayudarán a prevenir la mayoría de los errores, sin la necesidad de ejecutar el código en vivo, lo que es muy favorable también a la hora de hacer refactors.</p><h3 id="valores-por-defecto-segun-su-tipo-y-no-resultados-dinamicos" tabindex="-1"><a class="header-anchor" href="#valores-por-defecto-segun-su-tipo-y-no-resultados-dinamicos" aria-hidden="true">#</a> Valores por defecto según su tipo y no resultados dinámicos.</h3><p>Muchas veces he tenido que consumir APIs hechas por otros desarrolladores, las cuales lamentablemente respondían con datos difíciles de tratar, ya sea porque los objetos eran dinámicos o porque las propiedades de los objetos variaban en su tipo de dato, o porque estos objetos variaban en la cantidad de propiedades que contenían, etc. Esto me obligó a tener que programar permanentemente a la defensiva, es decir, debía preguntar en el código, usando condicionales, si los datos existían y si tenían el formato correcto para prevenir errores de ejecución, y si no tenían el formato correcto, debía reconvertirlo u obtenerlo de otro lado de la respuesta, cuestión que terminaba ensuciando mi código con el uso de muchos condicionales que prevenían errores y que, de alguna forma u otra, intentaban obtener los datos para poder manejarlos basándose en decisiones, es decir, más condicionales.</p><p>Otra cuestión que me sumaba complejidad técnica, sucedía cuando los datos no tenían un nombre bien descriptivo de que significaba, ni mucho menos podía intuir de que se trataba, O peor aun, cuando los datos no declaraban conclusiones o deducciones, y yo mismo con condicionales debía averiguar de que tipo de datos se trataban.</p><p>Considero que colocar valores por defecto es respetar el tipo de dato de una variable o propiedad, para que siempre mantenga el mismo tipo de dato, incluso cuando se ha intentado asignarle un valor vacío este debería seguir manteniendo el mismo formato. Cuando hablo de valores vacíos por defecto según su tipo, me refiero a que, por ejemplo, una propiedad que es un listado de objetos, jamás deberá tener otro valor que no sea un listado, y si el listado es vacío, no debe ser null, en su lugar debe ser un listado sin valores.</p><p>Lo mismo sucede con las propiedades que son números, que en todo momento no deben dejar de serlo, y en caso de querer representar un valor vacío por defecto será 0. Y en cuanto a las propiedades que son texto, estas deben tener un texto vacío y no un null, ni mucho menos, otro tipo de dato.</p><p>Por culpa de estas malas prácticas, la complejidad técnica que esto sumaba al código era tal que la productividad de todos se reducía considerablemente. Por suerte, aprendí, durante una meetup, una estrategia de como solucionarlo, normalizando los datos en la capa donde estos ingresan en la aplicación. Ya no tengo que intentar arreglar los datos, ni impedir errores en otras partes, he aprendido a solucionar la mayoría de los problemas relacionados con el mal manejo de los datos, no obstante, esto no deja de ser un problema, pero de esta forma se puede mitigar bastante.</p><h3 id="¿por-que-programacion-declarativa-y-no-imperativa" tabindex="-1"><a class="header-anchor" href="#¿por-que-programacion-declarativa-y-no-imperativa" aria-hidden="true">#</a> ¿Por qué programación declarativa y no imperativa?</h3><p>En varias ocasiones me he encontrado manteniendo código muy complejo, lleno de iteradores dentro de otros iteradores, y con muchos condicionales dentro. Resulta muy difícil poder entender el objetivo, o lo que se intenta resolver, dada la enorme cantidad de información visual expresada en el código sobre diferentes procesos, todos mezclados en una única solución.</p><p>El código que es declarativo, en cambio, ayuda a entender inmediatamente que es cada parte del conjunto de la solución, ya que cada avance en la solución es bien descriptiva y su código es escalado. Usar un código declarativo me hace ser más productivo al momento de agregar nuevas características, y conllevan a mayor productividad en la creacion de nuevas caracteristicas y en su mantenimiento a mediano y largo plazo.</p><h3 id="¿por-que-programacion-funcional-y-no-orientada-a-objetos" tabindex="-1"><a class="header-anchor" href="#¿por-que-programacion-funcional-y-no-orientada-a-objetos" aria-hidden="true">#</a> ¿Por qué programación funcional y no orientada a objetos?</h3><p>Cuando comencé a incursionar sobre temas relacionados sobre la programación declarativa, y sobre otras prácticas para crear código mantenible, dí con lo que es la programación funcional y, gracias a ella, considero que he mejorado enormemente la prolijidad con la que escribo código.</p><p>Gracias a la programación funcional he podido reducir líneas de código, al mismo tiempo que he podido desglosar soluciones complejas en muchas partes, las cuales fácilmente pueden ser reutilizadas por otras partes de la aplicación. Incluso puedo armar funciones nuevas utilizando otras ya existentes. Su inmutabilidad y el uso de funciones puras, me ayudan a crear código que es más predecible, sin tener que tratar con efectos colaterales indeseados. Y gracias a su recursividad y funciones de primera clase, puedo hacer partes de código muy flexibles y reutilizables.</p><p>La programación orientada a objetos la utilizo principalmente para modelar los datos, solo eso, el resto lo trabajo con la programación funcional, ya que me permite programar más fácilmente soluciones que son muy complejas.</p><h3 id="¿por-que-clean-arquitecture-y-no-cualquier-improvisacion-o-solucion-rapida" tabindex="-1"><a class="header-anchor" href="#¿por-que-clean-arquitecture-y-no-cualquier-improvisacion-o-solucion-rapida" aria-hidden="true">#</a> ¿Por qué Clean Arquitecture y no cualquier improvisación o solución rápida?</h3><p>Es muy común ver en proyectos, en los que hay que realizar mantenimiento, que los diferentes tipos de funcionalidades del código no estén agrupados, ni clasificados, ni ordenados, e incluso que estén mezclados con otros tipos de funcionalidades. Esto hace que sea difícil saber donde colocar las nuevas funcionalidades y, además, que sea poco intuitivo donde encontrar las funcionalidades que ya fueron hechas.</p><p>Otra situación frecuente, es ver que los proyectos no tienen un único patrón para realizar una determinada funcionalidad, o que las diferentes partes de la aplicación se comunican entre sí sin una jerarquía clara, ni tengan un flujo intuitivo en como se comunican estas partes. Todo este tipo de situaciones hacen que merme la productividad de todo un sector de desarrollo.</p><p>Clean Arquitecture viene a solucionar todos estos problemas relacionados con la organización del código. Hereda todas las prácticas de Clean Code, que están centradas en la calidad del código, pero las lleva a una escala superior para los proyectos, ordenando, clasificando y definiendo flujos de comunicación de cada una de sus partes, para lograr una correcta homogeneización. Establece reglas claras que resultan ser muy intuitivas para los desarrolladores cuando estos tienen que agregar y modificar características al proyecto.</p><p>Es cierto que con un simple y bien escalado MVC, MVP, MVVM es más que suficiente, pero existen otras arquitecturas que, si bien son más complejas de entender y aprender, son idóneas para proyectos que son realmente enormes y que deben durar mucho tiempo.</p><h3 id="¿por-que-github-flow-y-no-gitlab-flow" tabindex="-1"><a class="header-anchor" href="#¿por-que-github-flow-y-no-gitlab-flow" aria-hidden="true">#</a> ¿Por qué GitHub Flow y no GitLab Flow?</h3><p>Usar GitLab Flow tiene sus ventajas y desventajas. Permite atajar todos los errores de código con la utilización de múltiples ramas de desarrollo. Sin embargo, también es muy probable que surjan diferencias y conflictos de código entre las ramas. Esto implica que los desarrolladores continuamente deban invertir esfuerzo para resolver los conflictos, corriendo el riesgo de corregirlos incorrectamente. Esta dificultad se acentúa todavía más cuando la metodología ágil utilizada es SCRUM, porque las entregas se hacen después de mucho tiempo de desarrollo y las diferencias de código y conflictos son más grandes.</p><p>GitHub Flow, en cambio, nos propone un flujo de trabajo mucho más simplificado, con una única rama de desarrollo como la real, y cada cambio u modificación que se le haga a esta, debe ser tratado como si fuera el producto final. En vez de tener que invertir tanto esfuerzo en resolver conflictos de código, se lo invierte en mejorar la calidad del código nuevo.</p><p>GitHub Flow incentiva a los desarrolladores a hacer entregas continuas, pequeñas y de alta calidad, lo que es idóneo cuando se desea incorporar “integración continua” en el ambiente de producción, sin tener que esperar largos periodos de tiempos para que el cliente pueda ver los nuevos avances en su producto.</p><p>Siguiendo la misma línea de Kaizen, GitHub Flow plantea ir conquistando pequeños objetivos para lograr una meta final mayor, por lo tanto, se integra naturalmente a Kanban y Scrumban, metodologías que también son extremadamente ágiles y se basan en pequeñas tareas entregables.</p><h3 id="¿por-que-kanban-y-no-scrum" tabindex="-1"><a class="header-anchor" href="#¿por-que-kanban-y-no-scrum" aria-hidden="true">#</a> ¿Por qué Kanban y no SCRUM?</h3><p>Scrum es sin duda una metodología excelente cuando se la aplica correctamente, pero es realmente difícil implementarla para la mayoría de las empresas, en especial para todas aquellas que son pequeñas y medianas.</p><p>La dificultad de implementar SCRUM consiste en que no está preparada para afrontar cambios abruptos en el transcurso de un Sprint. El análisis, la planificación, la organización y la estimación de las tareas se realiza antes de que comience el Sprint. Sumar una tarea que no fue contemplada con anticipación acarrea caos. Cuando los desarrolladores se salen de las estimaciones por causas imprevistas, tienden a generar soluciones rápidas y de mala calidad, por ende acumulan deuda técnica que en el futuro afectará a la productividad.</p><p>SCRUM solo debe ser utilizado en equipos de trabajo grandes, porque se necesitan muchos roles adicionales y específicos para poder llevar a cabo la metodología ágil.</p><p>Kanban comparte similitudes con SCRUM, pero su enfoque es opuesto, ya que no cuenta con Sprints rígidos y muy planificados. Kanban recibe las tareas y su planificación forma parte del estado de la misma tarea, es decir, quienes crean, planifican, priorizan y diseñan las tareas, también participan en el tablero con los estados de estas. Por lo tanto, de esta manera es fácil ver como las tareas fluyen entre los diferentes estados, y se puede detectar en que estados hay cuellos de botella u otros problemas.</p><p>Gracias a que Kanban tiene estados para describir en que fase se encuentran las tareas, y que no requiere de reuniones largas y extensas (como las planning de SCRUM), las reuniones de planificación se hacen por tarea de forma separada de las demás, es decir, son reuniones mucho más cortas que no ocupan jornadas enteras de trabajo.</p><p>Kanban está alineado con la práctica Kaizen que consiste en dividir tareas complejas en objetivos pequeños e incrementales, donde cada tarea que representa un objetivo no puede durar más de dos o tres horas de trabajo, y si así lo fuese, se deberá dividir el objetivo aun más en tareas más pequeñas y concretas. Gracias a esto se puede estimar cuanto tiempo de desarrollo puede tomar una historia de usuario, contando la cantidad de objetivos y multiplicándolos por dos o tres horas.</p><p>En lo que se refiere a los cambios inesperados, y de último momento, que inevitablemente surgen, con Kanban se pueden incorporar perfectamente. Cada cambio será considerado como una nueva tarea. Luego se deberá establecer que tareas tienen que resolverse con mayor urgencia que otras y se les dará prioridad.</p><p>Kanban también es apropiado para equipos de trabajo grandes porque escala muy bien en ellos. Permite visualizar todas las tareas de todos los sectores, o de uno en concreto, filtrándolas por un sistema de etiquetado, y cada sector o grupo de trabajo puede tener sus propias etiquetas para identificar sus tareas con mayor facilidad.</p><p>Como si esto fuera poco, dado que las reglas de Kanban son muy concretas y simples, se le puede incorporar prácticas de otras metodologías. Es muy común que se incorporen ciertas prácticas de SCRUM por las necesidades de las empresas y de los clientes, transformando Kanban en Scrumban.</p><p>Según sea el caso, a veces es mejor armar pequeños grupos de trabajo multidisciplinarios, otras veces es mejor separar al equipo de IT en áreas grandes y especificas. Lo que si es seguro y tengo bien en claro es que Kanban es una metodología verdaderamente ágil, muy potente y altamente productiva.</p><h3 id="¿por-que-acordar-tareas-en-base-a-descripciones-y-no-en-base-a-palabras" tabindex="-1"><a class="header-anchor" href="#¿por-que-acordar-tareas-en-base-a-descripciones-y-no-en-base-a-palabras" aria-hidden="true">#</a> ¿Por qué acordar tareas en base a descripciones y no en base a palabras?</h3><p>A la hora de asignar y pactar las tareas que se van a resolver en el día, estas deben contar con una descripción bien detallada, y no pactarlas de palabra porque es muy frecuente que las personas se olviden lo que acordaron en reuniones previas. Además, en el caso de que se hayan tomado malas decisiones con respecto a los objetivos de las tareas, se puede recurrir a las dichas descripciones para respaldar el trabajo hecho y las decisiones que se tomaron en conjunto.</p><h3 id="considerar-todos-los-puntos-de-vista-y-no-asumir-veracidades-propias" tabindex="-1"><a class="header-anchor" href="#considerar-todos-los-puntos-de-vista-y-no-asumir-veracidades-propias" aria-hidden="true">#</a> Considerar todos los puntos de vista y no asumir veracidades propias</h3><p>La información y los datos son clave para la planificación de las tareas. Mientras más datos e información se posea, más certera va a hacer la planificación y el planteamiento de los objetivos, por esto, es importante hacer reuniones cortas con diferentes miembros del equipo, e incluso de diferentes áreas, los usuarios y los clientes, para poder conocer sus puntos de vista y lograr encontrar una convergencia entre todas las ideas. De esta manera, es posible detectar cuestiones que no fueron consideraras y que podrían acarrear grandes problemas en el futuro.</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">2/2/2023, 19:39:01</span></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"> ← <a href="/CV/experiencie.html" class="nav-link" aria-label="Experiencia Laboral"><!--[--><!--]--> Experiencia Laboral <!--[--><!--]--></a></span><span class="next"><a href="/CV/about.html" class="nav-link" aria-label="Sobre mi"><!--[--><!--]--> Sobre mi <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/CV/assets/js/runtime~app.fd959f96.js" defer></script><script src="/CV/assets/js/812.4ffac0d4.js" defer></script><script src="/CV/assets/js/app.81cd1d29.js" defer></script>
  </body>
</html>
